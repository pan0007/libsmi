\documentclass[conference]{IEEEtran}
\usepackage{graphicx}    % needed for including graphics e.g. EPS, P
\usepackage[pdftex]{hyperref}
\usepackage{listings}
\lstset{language=C}
\usepackage{url}
\begin{document}
\title{YANG Language Parser for Libsmi}
\author{\IEEEauthorblockN{Siarhei Kuryla}
\IEEEauthorblockA{Jacobs University Bremen\\
Spring Semester 2009\\
Supervisor: Prof. Dr. Juergen Schoenwaelder}
}

% make the title area
\maketitle

\begin{abstract}
NETCONF is a network management protocol developed in the IETF by the Netconf working group  which provides a simple mechanism through which a network device can be managed, configuration data information can be retrieved, and new configuration data can be uploaded and manipulated. YANG is a data modeling language used to model configuration and state data manipulated by the NETCONF protocol, NETCONF remote procedure calls, and NETCONF notifications. The YANG language is currently being developed by the IETF NETCONF Data Modeling Language Working Group. The libsmi is a library which provides a C API to access network management data model definitions written in various versions of the SMI (Structure of Management Information). The goal of this project is to extend a libsmi parser for the YANG data modeling language in order to make it compliant with the latest version of the YANG language.
\end{abstract}

\section{Introduction}
YANG is a data modeling language used to model configuration and state data manipulated by the NETCONF protocol, NETCONF remote procedure calls, and NETCONF notifications. Today, the NETCONF protocol \cite{bib1} lacks a standardized way to create data models. Instead, vendors are forced to use proprietary solutions. In order for NETCONF to be a interoperable protocol, models must be defined in a vendor-neutral way. YANG provides the language and rules for defining such models for use with NETCONF. 

YANG is posed as simple and easy to learn because of its trivial and regular syntax. This language is NETCONF-specific language designed to do what it needs to do well and it does not try to compete with XSD. YANG is fully modular and it enables development of certain parts of the model without influencing those parts that need no change. The YANG language is still under develoment and the latest draft version of this language was released on April 20, 2009 

Libsmi is a C library which provides a convenient API for handling network management data model definitions written in various versions of the SMI. The project's main task is to create a YANG parser for the library, update it's inner data structures to support the new language, and extend the API to support the new features of the YANG language.

\section{Motivation and problem statement}
The YANG language is still being developed and it is not yet widely used. Availability of convenient programming tools which support this modeling language might facilitate its adoption. Libsmi is  a portable C library that currently provides an API for access to various versions of the SMI. This library hides parsing details providing accessing SMI definitions for applications. Libsmi is a potential tool to be extented to support the YANG language. 

When I was starting working on the project there was already an incomplete parser implementation for libsmi based on the early version of the YANG specification  \cite{bib2}. The implementation was incomplete and suffered from a number of problems: 
\begin{itemize}
	\item the lexical analyser was implemented inaccurately. There were various problems with qouitings, line counting, string concatenation and some general rules were defined wrong;
	\item the syntactic analyser was implemented inaccurately. The implementation did not cover the whole grammar of the YANG language and there were many collisions with the specification;
	\item the implementation was incomplete: some language statements were stored to internal datastructures, others were not;
	\item the implementation tried to retrofit the YANG datamodel into existing libsmi data structures and API functions. However it caused many problems, making the parser much more complicated. It was confusing what functions we should use to handle a particular language definition, what data structure and members of the data structure correspond to the definition;
	\item there was no semantic analysis. References to groupings, types, features, and identities were not resolved, uniqueness of identifiers was not validated, modules knew nothing about definitions in their submodules.
\end{itemize}

This project aims at completing the parser for the YANG data modeling language in order to make it compliant with the latest version of the YANG language. At the time when the project was starting the available version of the specification was draft-ietf-netmod-yang-03 \cite{bib3} and it is used as a basis for the entire project.

\section{YANG language concepts}
The base unit of definition in YANG is a module, which defines a single data model. A module might be partitioned into a number of submodules that contribute definitions to the module. One module might refer other modules' definitions importing them. 

\section{Libsmi library}
The core of the libsmi library allows management applications to access SMI MIB module definitions. The structure of the library \cite{bib7} is internally divided into two layers. The upper layer provides the API to applications that make use of libsmi and internal data structures to management information in memory. The lower layer is a collection of drivers (actual parsers) that retrieve the management information from the SMI definitions. 

The libsmi library distribution also includes a collection of tools built on top of the library to check, analyze dump, convert, and compare MIB definitions.

In oder support a new modeling language by the libsmi library a driver for this language has to be implemented (a parser for the language), the way how to store language definitions in memory has to be specified by reusing already available data structures or implementing new ones, and the API to access module definitions has to be exposed. In order to be able to serialize module definitions stored in memory the smidump tool might be used which requites to implement a driver that defines the serialization rules.
\begin{figure}
\begin{center}
\includegraphics[scale=0.50]{libsmi.jpg}
\caption{ Libsmi structure}
\label{fig:libsmi}
\end{center}
\end{figure}

\section{Parsing overview}
The parsing of a YANG module is accomplished over several phases, which includes lexical, syntactic and semantic analysis.
\subsection{Lexical analysis}
Lexical analysis allows to convert an input sequence of characters into a sequence of tokens which are atomic language units such as keywords, identifiers, text segment and number definitions. A lexical analyzer processes the input characters to categorize them according to function, giving them meaning.

In the project lexical analysis is done by the lexical analyzer which is generated by the flex tool \cite{bib5}. The flex program reads a description of a lexical analyzer to generate from the given input file. The description is in the form of pairs of regular expressions and C statements associated with them. Flex generates as output a C source file which is a lexical analyzer for the given description. This output file has to be compiled and linked to produce an executable. When the executable is run, it analyzes its input for occurrences of the regular expressions and once it matches an input character seaquence with a regular expression it executes the C code associated with it.

The file \texttt{lib/scanner-yang.l} contains the description of the lexical analyzer for the YANG language. A token in YANG is either a keyword, a string, ";", "\{", or "\}". First of all, regular expressions for all keywords of the YANG language are defined and C statements which return the type of the keyword are associated with them. A string might be either unquoted  or enclosed within double or single quotes depending on the characters the string contains. Identifiers, identifier references (which are in the form prefix:identifier) and dates  are specific kinds of strings. The rules to handle all these kinds of strings are defined in the description of the lexical analyzer. If a quoted string is followed by a plus character ("+"), followed by
 another quoted string, the two strings have to be concatenated which is also accomplished here.

YANG supports two kinds of comments: a single line comment which starts with "//" and  ends at the end of the line; a block comment which is enclosed within "/*"  and "*/". The lexical analyzer contains rules which filter out both kinds of comments from the input character sequence.

Lexical analyser is also responsible for counting line numbers to assosicate them with tokens.

\subsection{Syntactic analysis}
Syntactic analysis processes a sequence of tokens obtained from the lexical analysis and determines their grammatical structure with respect to a given formal grammar. In other words, it checks whether it is possible to construct a particular sequence of tokens by applying grammar rules of the language. Apart from the validation for correct syntax the syntactic analysis also builds a parse tree for the input token sequence. 

In order to create a syntactic analyzer for the YANG language bison parser generator \cite{bib6} is used, which is a part of the GNU project. Bison converts a grammar description for a context-free grammar into a C program which can parse a sequence of tokens that conforms to that grammar. 

The file \texttt{lib/parser-yang.y} is a Bison grammar file that contains the grammar of the YANG language in Bison syntax. The first part of this grammar file is Bison declarations where the names of all terminal and nonterminal symbols are declared. The rest of the file implements the YANG ABNF grammar rules defined in the specification. In a Bison grammar, a grammar rule might have an action made up of C statements. Each time the parser recognizes a match for that rule, the action is executed. The assosicated with the grammar rules C statements accomplish simple validations and construct a representation of the parsing module in memory.

\subsection{Semantic analysis}
When the syntactic analysis is done we know that the YANG module is grammatically correct and we have the representation of the module in internal data structures, but it still does not mean that the  module is valid. Semantic analysis is the phase in which semantic information is added to tree built in the previos phase. This phase performs semantic checks which require a complete module tree. For instance, these are some examples of validations that have to be applied in this phase:
\begin{itemize}
\item resolve all references to user defined types, groupings, extensions, identities and features.
\item check whether there are no
  circular dependencies between various module elements such as user-defined types, groupings, identities, features and modules themselves;
\item check whether all identifiers have unique names in the scope of their namespaces;
\item check whether restrictions applied to user defined types don't create collisions;
\end{itemize}

\section{Data structures}
The output of the syntactic analysis is stored in memory in internal libsmi data structures. The library has two layers of data structures - public and private. The public data structures are exposed through the library API. The private data structures are used only inside the library itself and contain the corresponding public data structures, as well as many additional fields which are necessary in the validation phase. 

The libsmi library already contains a set of implemented data structures for other modeling languages. While adding support for the YANG language there were two options:
\begin{itemize}
\item try to retrofit YANG model into existing data structures and APIs;
\item create a separate set of data structures and API functions for YANG from scratch;
\end{itemize}

Each approach has some advantages and disadvantages. In the first case we might keep the API of the library unchanged and, theoretically, the applications that use the libsmi library and have been developed before don't require additional changes (or require minor changes). But, practically, it suffers from a number of limitations. The YANG language is pretty different from the languages libsmi supports and it would be not a trivial task to fit the YANG model into existing data structures and APIs. Even though it is doable it would be necessary to modify some existing datastructers and add new ones. It results in very complicated data structures some fields of which are used by one modeling language and not used by another one. As a result the development process gets extremely difficult because we have to operate on the data structures we have, but not ones that are best suited. In order to work with the library one should spend much time on learning how  data is actually stored. 

The later approach makes the development and usage of the library much simpler, but it loses the compatibility. We can create data structures which are best suited for the language model. It will also make the API of the library clearer. In order to support the compatibility at the API level it is possible to implement conversion functions which allow to convert a module between different languages. 

In the project the second approach was chosen: all necessary data structures and the public API were defined from scratch.

\subsection{Public data structures}
Public data structures and user defined types for the YANG language are declared in the \texttt{lib/yang.h} file. All of them are named with the \texttt{Yang} prefix. 

The \texttt{YangNode} data structure is used for representing YANG statements of any kind:
\small
\begin{center}
\begin{verbatim}
    typedef struct YangNode {
        YangString      value;
        YangString      extra;
        YangDecl        nodeKind;
        YangStatus      status;
        YangConfig      config;
        YangString      *description;
        YangString      *reference;
    } YangNode;
\end{verbatim}
\end{center}
\normalsize
The \texttt{nodeKind} field of the \texttt{YangDecl} enumerated C type specifies the kind of the YANG statement that corresponds to the node. The \texttt{YangDecl} type declares 65 possible values (e.g. \texttt{YANG\_DECL\_IMPORT}). The \texttt{YANG\_DECL\_UNKNOWN} value represents the statements which are user defined extensions.

The \texttt{value} field of the \texttt{YangString} type holds the argument of the statement.

The \texttt{extra} field of the \texttt{YangString} type is only used by the statements which are user defined extensions with an argument to store the argument.

The \texttt{status} field of the \texttt{YangStatus} type holds the value of the enclosed status statement (if the status is not present then the \texttt{YANG\_STATUS\_DEFAULT\_CURRENT} value).

The \texttt{config} field of the \texttt{YangConfig} type holds the value of the enclosed config statement (if the config is not present then the \texttt{YANG\_CONFIG\_DEFAULT\_CURRENT} value).

The \texttt{description} and \texttt{reference} fields of the \texttt{YangString} type hold the values of the enclosed description and reference statements respectively.

\subsection{Private data structures}
Private data structures are declared in the \texttt{lib/yang-data.h} file and have the \texttt{\_Yang} prefix in their names. 

All YANG module statements are represented in memory by the \texttt{\_YangNode} data structure:
\small
\begin{verbatim}
    typedef struct _YangNode {
        YangNode            export;
        YangNodeType        nodeType;
        void                *info;
        int                 line;
        struct _YangTypeInfo *typeInfo;
        struct _YangNode  	*firstChildPtr;
        struct _YangNode  	*lastChildPtr;    
        struct _YangNode  	*nextSiblingPtr;
        struct _YangNode  	*parentPtr;
        struct _YangNode  	*modulePtr;
    } _YangNode;
\end{verbatim}
\normalsize

The first \texttt{export} field of the \texttt{YangNode} type is a corresponding public data structure of a YANG node which is exposed through the API of the library. This fact allows to cast public data structure pointers to private data structure pointers, e.g.
\small
\begin{verbatim}
_YangNode *nodePtr = (_YangNode*)yangNodePtr
\end{verbatim}
\normalsize
where \texttt{yangNodePtr} is of the \texttt{YangNode} type.

The purpose of the \texttt{nodeType} field of the enumerated \texttt{YangNodeType} type is described later on in this report. All nodes corresponding to the  definitions of the YANG module have \texttt{YANG\_NODE\_ORIGINAL} as the value of this field.

The \texttt{info} pointer is used to  refer additional data stuctures which hold the information specific for different types of YANG statements. For instance, if the node represents the module statement then the pointer contains the reference to the \texttt{\_YangModuleInfo} data structure.

The \texttt{line} field holds the number of the line in the module file corresponding to the statement which is represented by the node.

The \texttt{typeInfo} field is intended to be used by nodes which represent the typedef statements (to hold a reference to the base type and restrictions applied to the type). At the present the type validations are not implemented, so the field is not used.

The \texttt{\_YangNode} data structure is a list, every element of which has a reference to the next element \texttt{nextSiblingPtr}. 

The \texttt{firstChildPtr}  and \texttt{lastChildPtr} fields hold pointers to the first and last nodes which represent statements enclosed into the current node.

The \texttt{parentPtr}  field holds a pointer to the node that represents the statement which encloses this one.

The \texttt{modulePtr}  field is a reference to the node corresponding to the module statement to which  the current node belongs.

\section{API functions}
At the present the public API for handling YANG module definitions is fairly poor. But all required data is stored in private data structures and later on another view on them might be exposed.

All YANG API functions have the \texttt{yang} prefix and are declared in the \texttt{lib/yang.h} file:
\begin{itemize}
\item \texttt{int yangIsModule(const char* name)} returns \texttt{true} if the module with the given name is a YANG module;
\item \texttt{YangNode *yangGetModule(char *name)} returns a pointer to the struct \texttt{YangNode} for the module with the given name or \texttt{NULL} if the YANG module with the given has not been loaded;
\item \texttt{YangNode *yangGetFirstModule(void)} returns a pointer to the struct \texttt{YangNode} that represents the first loaded YANG module or \texttt{NULL} if no one YANG module has been loaded;
\item \texttt{YangNode *yangGetNextModule(YangNode *yangModulePtr)} returns a pointer to the struct \texttt{YangNode} that represents the YANG module loaded after the given module \texttt{yangModulePtr} or \texttt{NULL} if there is no YANG module loaded after it;
\item \texttt{YangNode *yangGetFirstChildNode(YangNode *yangNodePtr)} returns a pointer to the struct \texttt{YangNode} that represents the first child node of the \texttt{yangNodePtr} node or \texttt{NULL} if that node does have child nodes;
\item \texttt{YangNode *yangGetNextSibling(YangNode *yangNodePtr)} returns a pointer to the struct \texttt{YangNode} that represents next sibling node of the \texttt{yangNodePtr} node or \texttt{NULL} if there is no next sibling node;
\item \texttt{int yangIsTrueConf(YangConfig conf)} returns \texttt{1} if the given \texttt{YangConfig} value is true and \texttt{0} otherwise.
\end{itemize}

The API functions which provide initialization and adjustment operations for the libsmi library are left the same:
\begin{itemize}
\item the \texttt{int smiInit(const char *tag)} function initializes internal data structures;
\item the \texttt{void smiExit(void)} function releases allocated resources;
\item the \texttt{char *smiLoadModule(const char *module)} function loads a module with the given name in memory;
\end{itemize}

\section{Implementation details}
\subsection{Module tree constrution}
Loading of a module in memory is triggered by the function \texttt{smiLoadModule(const char *module)} call with a parameter that represents the module name. This function verifies whether the module is defined in the YANG language and, if so, executes the function \texttt{loadYangModule(const char *modulename, const char *revision, Parser *parserPtr)}. Then the \texttt{Parser} data structure is initialized and the parser generated by Bison starts analyzing module definitions.

While validating the grammar of the module C statements associated to the grammar rules are executed. These statements accomplish some additional validations that don't require a complete module representation in memory and for every module definition create the corresponding node in the parsing tree by executing the function:

\small
\begin{verbatim}
   _YangNode *addYangNode(const char *value, 
                          YangDecl nodeKind, 
                          _YangNode *parentPtr)
\end{verbatim}
\normalsize

The first parameter \texttt{value} of the function is the argument of the YANG statement (e.g., the name of the module for the module statement, an XPath expression for the must, when and augment statements). The second parameter represents the kind of the YANG statement that corresponds to the created node. And the last parameter is a pointer to the parent node.

For some module tree nodes the \texttt{info} field of the \texttt{\_YangNode} data stucture is initialized, which depends on the type of the YANG statement:
\subsubsection{'module' and 'submodule' statements}
the \texttt{info} field refers to the \texttt{\_YangModuleInfo} data structure:

\small
\begin{verbatim}
   typedef struct _YangModuleInfo {
       char              *prefix;
       char              *version;
       char              *namespace;
       char              *organization;
       char              *contact;
       _YangParsingState parsingState;
       int               conformance;
       struct _YangNode  *originalModule;
       struct _YangNodeList *submodules;
       struct _YangImportList *imports;
       void                   *parser;
} _YangModuleInfo;
\end{verbatim}
\normalsize
The \texttt{prefix}, \texttt{namespace}, \texttt{organization} and \texttt{contact} fields hold the values of the prefix, namespace, organization and contact statements enclosed into the module or submodule.

The \texttt{version} field contains the specified version of the YANG language.

The \texttt{parsingState} field of the enumerated \texttt{\_YangParsingState} type may contain one out of two values:
\begin{itemize}
\item \texttt{YANG\_PARSING\_IN\_PROGRESS} – for modules which are currently being parsed;
\item \texttt{YANG\_PARSING\_DONE} – for modules for which the parsing has been finished;
\end{itemize}

\subsection{Import and include modules by revision}
YANG allows to specify the revision of the imported module or included submodule. When a module is published, it uses the current available revisions of other modules. Publishing new revisions of the imported modules  does not affect the importing module, since it still uses revisions which have been published before. This YANG mechanism allows modules to evolve independently over time. 

According to the specification, YANG modules and submodules are typically stored in files, one module or submodule per file, and the name of the file should be on the form:
\small
\begin{verbatim}
(sub)module-name ['.' revision-date] ('.yang')
\end{verbatim}
\normalsize

\section{Smidump driver}
Smidump is a program which comes with the libsmi library distribution and allows to dump the content of a MIB module in various language formats. In the course of the project the YANG driver for smidump was implemented. It allows to print a YANG module stored in memory back to text format YANG definitions. Currently it is not very useful, because there is no converter from any other format to YANG and the driver might be used only to dump YANG modules. But it might be employed for testing of the YANG parser.

The file \texttt{tool/dump-yang-sk.c} contains the implementation of the driver, which traverses the entire module node hierarchy and serializes all nodes. The driver is registered with the \texttt{yang-sk} name.

\section{Testing}
From the very begging of the project  while implementing a new grammar rule or check I have been trying to create a test case that allows to validate that rule or check. Every test case consists of two files: an input file that contains YANG module definitions and the file with the expected output for that test case. In order to test the library on a certain test the smilint tool has to be executed on the test input file and the obtained output file has to be compared to the expected one. All test files are available in the folder 	\texttt{test/yang} of the library infrastructure.

In order to automate the process of running all test cases at once there is a script available at \texttt{test/parser-yang.test}. Having changed the source code of the YANG parser, now it is easy to validate whether something has been broken by simple automated running of all test cases.

\section{Related work}
Pyang \cite{bib8} is a YANG validator, transformator and code generator, written in python. It can be used to validate YANG modules for correctness, to transform YANG modules into other formats such as YIN, DSDL and XSD, and to generate code from the module definitions. While working on the project I have been constantly using that tool to clarify vague parts of the YANG specification. At the same time I have been testing pyang and I have found a number of issues which I reported to the pyang bug tracking system. All reported issues are available at the following addresses:
\begin{itemize}
\item \url{http://code.google.com/p/pyang/issues/detail?id=5}
\item \url{http://code.google.com/p/pyang/issues/detail?id=6}
\item \url{http://code.google.com/p/pyang/issues/detail?id=7}
\item \url{http://code.google.com/p/pyang/issues/detail?id=8}
\item \url{http://code.google.com/p/pyang/issues/detail?id=9}
\item \url{http://code.google.com/p/pyang/issues/detail?id=10}
\item \url{http://code.google.com/p/pyang/issues/detail?id=11}
\item \url{http://code.google.com/p/pyang/issues/detail?id=12}
\item \url{http://code.google.com/p/pyang/issues/detail?id=13}
\item \url{http://code.google.com/p/pyang/issues/detail?id=14}
\item \url{http://code.google.com/p/pyang/issues/detail?id=15}
\item \url{http://code.google.com/p/pyang/issues/detail?id=17}
\end{itemize}

\section{Conclusions}

\begin{thebibliography}{1}
\bibitem[1]{bib1} R. Enns. RFC4741 NETCONF Configuration Protocol. Technical report, Network Working Group.,
December 2006.
\bibitem[2]{bib2} M. Bjorklund. YANG - A data modeling language for NETCONF draft-ietf-netmod-yang-02. Technical report, Network Working Group. February 2008.
\bibitem[3]{bib3} M. Bjorklund. YANG - A data modeling language for NETCONF draft-ietf-netmod-yang-03. Technical report, Network Working Group. February 2009.
\bibitem[4]{bib4} M. Bjorklund. YANG - A data modeling language for NETCONF draft-ietf-netmod-yang-05. Technical report, Network Working Group. April 2009.
\bibitem[5]{bib5} flex - The fast lexical analyser. \url{http://flex.sourceforge.net/}, May 2009.
\bibitem[6]{bib6} Bison - GNU parser generator. \url{http://www.gnu.org/software/bison/}, May 2009.
\bibitem[7]{bib7} libsmi - A library to access SMI MIB Information. \url{http://www.ibr.cs.tu-bs.de/projects/libsmi/}, May 2009.
\bibitem[8]{bib8} pyang - An extensible YANG validator and converter in python. \url{http://code.google.com/p/pyang/}, May 2009.

\end{thebibliography}

\end{document}


